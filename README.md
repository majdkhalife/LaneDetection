# Lane Detection Using Classical Computer Vision (C++ & OpenCV)

Welcome to my Lane Detection project!
This repository implements a full **lane detection pipeline** using classical computer vision techniques.
The project is written in **C++**, uses **OpenCV**, and is structured with modularity in mind, similar to real-world robotics and embedded systems codebases.

Before deep learning became mainstream, lane detection relied purely on **geometry**, not neural networks.
This project recreates that classical approach from scratch.

# Why Traditional Lane Detection?

You might be asking:

> **â€œWhy bother with classical methods when I could train a deep learning model?â€**

Great question, hereâ€™s why I think traditional methods still matter:

* **Real-time performance:** Runs at full FPS even on low-power CPUs
* **No GPU required:** Works on embedded devices
* **No training data:** No dataset collection, labeling, or training pipeline
* **Interpretable:** Every step is transparent and tunable

### Core principles behind classical lane detection

Before AI, lanes were detected because of simple geometric properties:

* **Road edges** -> strong gradients -> extract with **Canny**
* **Lane lines** -> mostly straight -> detect with **Hough Transform**
* **Left/right lanes** -> opposite slope signs -> filter by slope
* **Parallel lines** -> appear to converge -> average slopes + intercepts

Despite their simplicity, these techniques still deliver surprisingly good results.

# Project Overview

This pipeline follows the classic highway lane-detection sequence:

### **1. Read & decode video frames**

Load dashcam footage using `cv::VideoCapture`.

### **2. Region of Interest **

Mask everything except the road area directly ahead.
This removes irrelevant edges such as sky, signs, trees, and guard rails.

### **3. Convert to Grayscale**

Lane detection relies on contrast, not color.

### **4. Gaussian Blur**

Smooths noise and prevents false Canny responses.

### **5. Canny Edge Detection**

Extracts strong gradients which is ideal for detecting lane boundaries.

### **6. Apply ROI Mask**

Only edges inside the polygon-shaped ROI are kept.

### **7. Hough Line Transform**

Detects straight lines from the masked edge image.

### **8. Filter & Average Segments**

* Negative slope -> **left lane**
* Positive slope -> **right lane**
  Weighted by segment length for stability.

### **9. Draw final lane lines**

Two stable, long lane boundaries are drawn on the original image.

Each step of the pipeline is implemented inside its own `.cpp` and `.h` files for clarity and modularity.


# ðŸ› ï¸ CMake & Make (Simplified Explanation)

## **1) What is CMake?**

CMake is a **build system generator**.
It reads your `CMakeLists.txt` and generates build instructions for your compiler.

> **CMake = the recipe writer**
> It writes *how* your program should be compiled.

## **2) What is Make?**

Make is the actual build tool.
It reads the Makefile generated by CMake and compiles your code.

> **Make = the chef**
> It cooks according to CMakeâ€™s recipe.

# ðŸ”„ When to Run CMake vs. Make

### Run **`cmake ..`** when:

* First time setting up the project
* You add/remove `.cpp` files
* You modify `CMakeLists.txt`
* You reorganize files/folders

### Run **`make`** when:

* You edit any existing `.cpp` or `.h` file
* You want to rebuild after small code changes
* You already ran `cmake ..` at least once

# The Vanishing Point Effect

### Why the detected lines form a big **X** on the horizon

In the output, the left and right lane lines may appear to intersect at the top of the image.
This is **normal** in classical lane detection.

### Why this happens:

* Real lane lines are **parallel** in the real world
* A camera projects 3D -> 2D, creating a **vanishing point**
* All parallel lines appear to converge at that point
* The algorithm extends lane lines using slope + intercept
* Extended straight lines naturally meet at the horizon

# Conclusion

This project demonstrates how classical computer vision can still deliver effective lane detection:

* Real-time performance
* Transparent and interpretable steps
* No machine learning required
* High portability (runs anywhere C++ and OpenCV can run)
